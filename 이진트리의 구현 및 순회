// 이진트리(Binary Tree)는 테이터의 탐색 속도 증진을 위해 사용되는 비선형 자료구조
// 완전 이진트리가 아니므로 포인터를 사용

1. 전위 순회(Preorder Traversal)
 1) 먼저 자기 자신 처리
 2) 왼쪽 자식 방문
 3) 오른쪽 자식 방문
 1 - 2 - 4 - 8 - 9 - 5 - 10 - 11 - 3 - 6 - 12 - 13 - 7 - 14 - 15

2. 중위 순회(Inorder Traversal)
 하나의 노드 방문시 아래 순서를 따른다
 1) 왼쪽 자식 방문
 2) 먼저 자기 자신 처리
 3) 오른쪽 자식 처리
 8 - 4 - 9 - 2 - 10 - 5 - 11 - 1 - 12 - 6 - 13 - 3 - 14 - 7 - 15
 
3. 후위 순회(Postorder Traversal)
 1) 왼쪽 자식 방문
 2) 오른쪽 자식 방문
 3) 먼저 자기 자신 처리
 8 - 9 - 4 - 10 - 11 - 5 - 2 - 12 - 13 - 6 - 14 - 15 - 7 - 3 - 1
 
typedef struct node* treePointer; //포인터 형태로 사용하기 위해 
typedef struct node {
	int data;
	treePointer le, ri; //왼쪽, 오른쪽을 가리키는 포인터
}; node;

//전위 순회
void preorder(treePointer ptr) { 
	if (ptr) { //포인터가 비어있지 않고 노드를 가리킨다면
		cout << ptr->data << ' '; //먼저 자기 자신 처리
		preorder(ptr->le); //재귀적으로 왼쪽
		preorder(ptr->ri); //재귀적으로 오른쪽
	}
}

//중위 순회
void inorder(treePointer ptr) {
	if (ptr) { //포인터가 비어있지 않고 노드를 가리킨다면
		inorder(ptr->le); //재귀적으로 왼쪽
		cout << ptr->data << ' '; //먼저 자기 자신 처리
		inorder(ptr->ri); //재귀적으로 오른쪽
	}
}

//후위 순회
void postorder(treePointer ptr) {
	if (ptr) { //포인터가 비어있지 않고 노드를 가리킨다면
		postorder(ptr->le); //재귀적으로 왼쪽
		postorder(ptr->ri); //재귀적으로 오른쪽
		cout << ptr->data << ' '; //먼저 자기 자신 처리
	}
}

//이진 트리 생성
int main(void) {
	node nodes[number + 1];
	for (int i = 1; i <= number; i++) {
		nodes[i].data = i;
		nodes[i].le = 0;
		nodes[i].ri = 0;
	}
	for (int i = 1; i <= number; i++) {
		if (i % 2 == 0) { //자식노드가 짝수라면 왼쪽노드에 삽입
			nodes[i / 2].le = &nodes[i]; //포인터 형식으로 주소를 입력
		}
		else {
			nodes[i / 2].ri = &nodes[i];
		}
	}
	return 0;
}
