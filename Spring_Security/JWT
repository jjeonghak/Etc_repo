//등장배경
  트래픽이 몰리는 경우 서버는 로드 밸런싱을 사용해 서버를 분산해서 관리
  서버를 분산해서 세션 저장소도 각각으로 분리
  로그인을 한 사용자가 이전의 서버가 아닌 새로운 서버로 요청하는 경우 다시 로그인을 하는 문제 발생
  db에 세션을 저장하는 것은 i/o가 발생해서 속도가 느림
  메모리 공유를 통해 각각의 서버가 같은 세션 저장소를 공유하는 방식도 등장(redis)
  이러한 문제점을 해결하기 위해 jwt 방식 등장


//정보보안
  보안의 3요소 CIA
  키 전달 문제와 수신자에 대한 인증 문제 발생
  
    1. 기밀성(Confidentiality) : 정보는 오직 인가된 사용자만 허가
    2. 무결성(Integrity) : 부적적한 정보 변경 또는 파기 없이
    3. 가용성(Availability) : 신뢰할 수 있는 정보로 언제나 접근 가능


//RSA
  키쌍을 이용한 암호화 방식
  수신자의 공개키로 데이터를 잠그면 수신자의 개인키로만 조회가능(암호화)
  발신자의 개인키로 데이터를 잠그면 발신자의 공개키로 조회가능(인증) 
  
    1. 공개키(public key) : 외부에 키를 노출해서 사용
    2. 개인키(private key) : 오직 자신만 보유해서 사용


//HS256
  원본 메시지와 공유된 메시지를 비교하고 변조 여부를 확인(MAC, message authentication code)
  원본 메시지가 변하면 그 해시값도 변하는 해싱의 특징을 이용


//Json Wwb Token
  RFC 7519 웹 표준
  전자 서명된 URL-safe Json
  전자 서명을 이용해 토큰 변조를 확인
  Json 객체를 이용해 토큰 자체에 정보를 저장
  중앙의 인증서버, 데이터 스토어에 대한 의존성 없음(시스템 수평 확장 유리)
  Base64 URL Safe Encoding 방식 사용(url, cookie, header 모두 사용 가능)
  Payload 정보가 많아지면 네트워크 사용량 증가, 데이터 설계 고려 필요
  토큰이 클라이언트에 저장, 서버에서 클라이언트의 토큰을 조작 불가
  Header, Payload, Signature 3 부분으로 구성
    
    1. Header : Signature 해싱에 필요한 알고리즘 정보
    2. Payload : 서버와 클라이언트가 주고받는 시스템에 이용되는 실제 정보
    3. Signature : 토큰의 유효성 검증을 위한 문자열



