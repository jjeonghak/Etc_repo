// 시간 복잡도 : 평균O(N*logN), 최악O(N^2) 
// 특정한 값(피벗)을 기준으로 큰 숫자와 작은 숫자를 서로 교환한 뒤 배열을 반으로 나눔

void quickSort(int* data, int start, int end) {
	if (start >= end) return; //원소가 하나인 경우

	int key = start;
	int i = start + 1;
	int j = end;
	int temp;

	while (i <= j) { //서로 엇갈릴 때까지
		while (i <= end && data[i] <= data[key]) { //키 값보다 큰 값을 만날 때까지
			i++;
		}
		while (j > start && data[j]>= data[key]) { //키 값보다 작은 값을 만날 때까지
			j--;
		}
		if (i > j) { //현재 엇갈린 상태면 키 값과 교체
			temp = data[j];
			data[j] = data[key];
			data[key] = temp;
		}
		else { //엇갈리지 않았다면 i와 j 교체
			temp = data[i];
			data[i] = data[j];
			data[j] = temp;
		}
	}

	quickSort(data, start, j - 1);
	quickSort(data, j + 1, end);
} 
