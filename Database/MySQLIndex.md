# 인덱스
인덱스 특성솨 치이는 물리 수준 모델링에 중요한 요소  
기존 MyISAM 스토리지 엔진에서만 제공하던 전문 검색, 위치 기반 검색 기능도 지원  
쿼리 튜닝의 기본  

<br>

## 디스크 읽기 방식
전기적 특성을 띤 장치의 성능은 크게 발전했지만 디스크와 같은 기계식 장치 성능은 제한적으로 발전  

<br>

### 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
데이터베이스 서버에서 항상 디스크 장치가 병목 지점  
하드 디스크 드라이브를 대체하기 위한 전자식 저장 매체 SSD 출시  
기존 하드 디스크에서 데이터 저장용 플래터를 제거하고 그 대신 플래시 메모리 장착  
메모리(D-Ram)보단 느리지만 기계식 하드 디스크보다 빠름  

<br>

디스크 헤더를 움직이지 않고 한번에 많은 데이터를 읽는 순차 I/O에서는 비슷한 성능  
하지만 랜덤 I/O에서 훨씬 빠른 성능 제공  

<br>

## 인덱스란?
칼럼의 값과 해당 레코드가 저장된 주소를 키와 값 쌍으로 저장한 형태  
데이터 저장 성능을 희생시키고 대신 읽기 속도를 높이는 기능  

- 프라이머리 키는 대표 칼럼 값으로 만들어진 인덱스  
`Null` 값과 `중복`을 허용하지 않음  

- 세컨더리 키는 프라이머리 키를 제외한 나머지 모든 인덱스  
그중 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 대체 가능하기 때문에 대체 키로도 표현  

<br>

데이터 저장 방식별로 구분 가능  
대표적으로 `B-Tree` 인덱스와 `Hash` 인덱스로 구분  

- `B-Tree` 알고리즘은 가장 일반적으로 사용되는 인덱스 알고리즘  
칼럼 값을 변형하지 않고 원래 값을 이용해 인덱싱  
위치 기반 검색을 지원하기 위해 `R-Tree` 인덱스도 지원하지만 결국 `B-Tree` 응용 알고리즘  

- `Hash` 인덱스 알고리즘은 칼럼의 값으로 해시값 계산  
매우 빠른 검색을 지원하지만 전방 일치 같은 값의 일부만 검색하거나 범위 검색 불가  
주로 메모리 기반 데이터베이스에서 사용  

<br>

## B-Tree 인덱스
가장 범용적인 목적으로 사용되는 인덱스 알고리즘  
`B+-Tree` 인덱스도 변형된 형태의 알고리즘  
인덱스 구조체 내에서 항상 정렬된 상태로 유지  

<br>

### 구조 및 특성

<img width="650" alt="b-treestructure" src="https://github.com/user-attachments/assets/6f8ce061-2f1e-422f-bdc3-43a6ec3197a5" />

최상위 루트 노드가 존재하고 그 하위에 자식 노드가 붙어있는 형태  
데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장  
인덱스는 테이블 키 칼럼만 보유, 나머지 칼럼을 조회하려면 데이터 파일에서 해당 레코드 탐색 필수  
이를 위해 리프 노드는 데이터 파일에 저장된 레코드 주소를 보유  

<br>

<img width="750" alt="b-treeleafnode" src="https://github.com/user-attachments/assets/55e0e855-e45d-4afb-8844-1442edb23c1d" />

InnoDB 스토리지 엔진은 프라이머리 키가 `ROWID` 역할 담당  
두 스토리지 엔진의 인덱스 차이점은 세컨더리 인덱스를 통해 데이터 파일의 레코드를 찾아가는 방식  
MyISAM 테이블은 세컨더리 인덱스가 물리적인 주소를 보유  
반면 InnoDB 테이블은 세컨더리 인덱스가 프라이머리 키를 주소처럼 사용하기에 논리적인 주소 보유  
즉, InnoDB 스토리지 엔진의 모든 세컨더리 인덱스 검색은 반드시 프라이머리 키를 다시 한번 검색  

<br>

### B-Tree 인덱스 키 추가 및 삭제
테이블 레코드 생성/변경/삭제하는 경우 인덱스에도 추가 작업 발생  

<br>

### 인덱스 키 추가
새로운 값이 저장될 때 스토리지 엔진에 따라 바로 인덱스에 저장될 수도 있고 아닐 수도 있음  
우선 적절한 위치를 검색한 후 리프 노드가 꽉 차있는 경우 리프 노드 분리 필요  
이런 작업 탓에 상대적으로 쓰기 작업은 많은 비용 발생  

MyISAM이나 MEMORY 스토리지 엔진의 경우 바로 새로운 값을 인덱스에 추가  
InnoDB 스토리지 엔진의 경우 지연 처리 가능  
하지만 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 처리  

<br>

### 인덱스 키 삭제
추가 작업보다 상대적으로 간단  
해당 키 값을 찾아 삭제 마크만 하면 작업 완료  
삭제 마킹된 인덱스 키 공간은 방치 또는 재활용 가능  
디스크 I/O 작업은 지연 처리 가능  

<br>

### 인덱스 키 변경
단순히 인덱스 상의 키 값만 변경하는 것 불가  
먼저 키 값을 삭제한 후 다시 새로운 키 값을 추가하는 형태로 처리  

<br>

### 인덱스 키 검색
변경 작업을 할때 인덱스 관리에 따른 추가 비용을 감수하는 이유  
100% 일치, 앞부분(left-most part) 일치, 부등호 비교 조건에 사용 가능하지만 키 값의 뒷부분 용도로는 사용 불가  
또한 함수나 연산 수행 결과로 검색하는 작업은 `B-Tree` 장점 이용 불가  

<br>

### B-Tree 인덱스 사용에 영향을 미치는 요소
칼럼의 크기, 레코드 건수, 유니크 인덱스 키 값의 갯수 등에 영향  

<br>

### 인덱스 키 값의 크기
디스크에 데이터를 저장하는 가장 기본 단위는 페이지(`page`) 또는 블록(`block`)  
디스크의 모든 읽기/쓰기 작업의 최소 단위  
또한 페이지는 InnoDB 스토리지 엔진 버퍼풀에서 데이터 버퍼링 기본 단위  
인덱스도 결국 페이지 단위로 관리  

<br>

일반적으로 B-Tree 자식 노드의 갯수는 가변적  
최대 자식 노드 갯수는 `인덱스 페이지 크기`와 `키 값의 크기`에 따라 결정  
페이지 크기는 `innodb_page_size` 시스템 변수로 설정 가능하지만 기본값은 `16KB`  
































