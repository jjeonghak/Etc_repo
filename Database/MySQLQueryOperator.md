# 쿼리 작성 및 최적화
데이터베이스나 테이블 구조를 변경하기 위한 문장을 DDL(`Data Definition Language`)  
테이블의 데이터를 조작하기 위한 문장을 DML(`Data Manipulation Language`)  
애플리케이션은 데이터베이스에 SQL 쿼리만 전달하며, 해당 쿼리를 어떻게 처리할지는 MySQL 서버가 결정  

<br>

## MySQL 연산자

### 동등(Equal) 비교(=, <=>)
MySQL에서는 동등 비교를 위해 `<=>` 연산자도 제공  
부가적으로 NULL 값에 대한 비교까지 수행(`NULL-safe`)  

```
mysql> SELECT 1 = 1, NULL = NULL, 1 = NULL;
+-------+-------------+----------+
| 1 = 1 | NULL = NULL | 1 = NULL |
+-------+-------------+----------+
|     1 |        NULL |     NULL |
+-------+-------------+----------+

mysql> SELECT 1 <=> 1, NULL <=> NULL, 1 <=> NULL;
+---------+---------------+------------+
| 1 <=> 1 | NULL <=> NULL | 1 <=> NULL |
+---------+---------------+------------+
|       1 |             1 |          0 |
+---------+---------------+------------+
```

<br>

### 부정(Not-Equal) 비교(<>, !=)
어떤 연산자를 사용해도 문제없지만, 가독성을 위해 한가지로 통일하는 것 권장  

<br>

### NOT 연산자(!)
TRUE 또는 FALSE 연산의 결과를 반대로 만드는 연산자  
숫자에도 사용 가능하지만 부정의 결과값을 정확히 예측할 수 없는 경우 사용 자제  

<br>

### AND(&&)와 OR(||) 연산자
오라클은 `||` 연산자를 불리언 표현식의 결합 연산자가 아닌 문자열을 결합하는 연산자로 사용  
만약 MySQL에서도 똑같이 사용하고 싶다면 `sql_mode` 시스템 변수값에 `PIPES_AS_CONCAT` 설정  

```
mysql> SET sql_mode = 'PIPES_AS_CONCAT';
mysql> SELECT 'abc' || 'def' AS concated_string;
+-----------------+
| concated_string |
+-----------------+
|          abcdef |
+-----------------+
```

<br>

### 나누기(/, DIV)와 나머지(%, MOD) 연산자
```
mysql> SELECT 29 / 9;
+--------+
| 3.2222 |
+--------+

mysql> SELECT 29 DIV 9;
+--------+
|      3 |
+--------+

mysql> SELECT 29 % 9;
+--------+
|      2 |
+--------+

mysql> SELECT 29 MOD 9;
+--------+
|      2 |
+--------+
```

<br>

### REGEXP 연산자
문자열 값이 어떤 패턴을 만족하는지 확인하는 연산자(인덱스 사용 불가)  
RLIKE 연산자를 가끔 오른쪽 일치용 LIKE 연산자로 혼동하지만, 정규 표현식을 비교하는 연산자  
정규 표현식은 POSIX 표준으로 구현  

```
mysql> SELECT 'abc' REGEXP '^[x-z]';
+-----------------------+
|                     0 |
+-----------------------+
```

<br>

### LIKE 연산자
REGEXP 연산자보다 훨씬 단순한 문자열 패턴 비교 연산자이지만, 훨씬 많이 사용(인덱스 사용 가능)  
정규 표현식을 검사하진 않으며 상수 문자열이 존재하는지 정도를 판단  
사용할 수 있는 와일드 카드 문자는 `%` 또는 `_`  
와일드 카드 문자가 검색어 뒤쪽에 있다면 레인지 스캔 가능  

<br>

### BETWEEN 연산자
크거나 같다와 작거나 같다라는 두 개의 연산자를 하나로 합친 연산자  
일반적으로 BETWEEN 연산자보단 IN 연산자가 좀 더 효율적  

<img width="350" alt="betweenandin" src="https://github.com/user-attachments/assets/2e8c0e9f-f0b2-496c-9e04-61646f8b2ddf" />

```
mysql> SELECT * FROM dept_emp USE INDEX(PRIMARY)
       WHERE dept_no BETWEEN 'd003' AND 'd005' AND emp_no = 10001;
+----+----------+-------+---------+---------+--------+-------------+
| id | table    | type  | key     | key_len | rows   | Extra       |
+----+----------+-------+---------+---------+--------+-------------+
|  1 | dept_emp | range | PRIMARY | 20      | 165571 | Using where |
+----+----------+-------+---------+---------+--------+-------------+

-- // 다른 조건과 결합해서 더욱 효율적으로 탐색 가능
mysql> SELECT * FROM dept_emp USE INDEX(PRIMARY)
       WHERE dept_no IN ('d003', 'd004', 'd005') AND emp_no = 10001;
+----+----------+-------+---------+---------+------+-------------+
| id | table    | type  | key     | key_len | rows | Extra       |
+----+----------+-------+---------+---------+------+-------------+
|  1 | dept_emp | range | PRIMARY | 20      |    3 | Using where |
+----+----------+-------+---------+---------+------+-------------+
```

<br>

### IN 연산자
여러 값에 대해서 동등 비교 연산을 수행하는 연산자  
범위로 검색하는 것이 아닌 여러 번의 동등 비교로 실행하기 때문에 빠르게 처리  
NOT IN 연산자의 경우 일반적으로 풀 테이블 스캔 실행  

```
mysql> SELECT *
       FROM dept_emp
       WHERE (dept_no, emp_no) IN (('d001', 10017), ('d002', 10144), ('d003', 10054));
+----+----------+-------+---------+---------+------+-------------+
| id | table    | type  | key     | key_len | rows | Extra       |
+----+----------+-------+---------+---------+------+-------------+
|  1 | dept_emp | range | PRIMARY | 20      |    3 | Using where |
+----+----------+-------+---------+---------+------+-------------+
```

<br>
