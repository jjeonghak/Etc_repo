# 인덱스
인덱스 특성과 치이는 물리 수준 모델링에 중요한 요소  
기존 MyISAM 스토리지 엔진에서만 제공하던 전문 검색, 위치 기반 검색 기능도 지원  
쿼리 튜닝의 기본  

<br>

## 클러스터링 인덱스
클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원  

<br>

### 클러스터링 인덱스
테이블의 프라이머리 키에 대해서만 적용  
프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것  
프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 위치가 변경  
인덱스 알고리즘이라기보다는 테이블 레코드 저장 방식에 더 가까운 인덱스  

<br>

<img width="500" alt="clusteringindex" src="https://github.com/user-attachments/assets/b4bf4f7c-4800-44fe-a253-57ca570c5d59" />

클러스터링 테이블 구조 자체는 일반 B-Tree 인덱스와 유사  
하지만 세컨더리 인덱스의 리프 노드와 달리 클러스터링 인덱스의 리프 노드에는 레코드의 모든 칼럼 값이 저장  
클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리  

<br>

```sql
UPDATE tb_test SET emp_no = 1000002 WHERE emp_no = 1000007;
```

<img width="500" alt="updateprimarykey" src="https://github.com/user-attachments/assets/bbb4270d-d391-41b2-a9f2-25bab5237c33" />

만약 프라이머리 키 값을 변경하면 레코드 저장 페이지가 변경  
InnoDB 스토리지 엔진을 제외한 다른 스토리지 엔진은 프라이머리 키나 인덱스 키 값이 변경되도 실제 데이터 레코드 위치가 변경되지 않음  

<br>

프라이머리 키가 없는 테이블은 우선순위대로 프라이머리 키를 대체할 키를 선택  
1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
2. NOT NULL 옵셥의 유니크 인덱스 중에서 첫번쨰 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후, 클러스터링 키로 선택

만약 클러스터링 키 후보를 찾지 못해서 자동 생성 클러스터링 키를 적용한 경우 해당 칼럼은 사용자에게 노출되지 않고 쿼리로 명시 불가  
클러스터링 인덱스는 테이블 당 단 하나만 보유 가능하기 때문에 명시적으로 생성하는 것을 권장  

<br>

### 세컨더리 인덱스에 미치는 영향
MyISAM이나 MEMORY 테이블 같은 클러스터링되지 않은 테이블은 레코드 생성될 때 처음 저장된 공간에서 절대 이동하지 않음  
데이터 레코드가 저장된 주소는 내부적인 레코드 아이디(`ROWID`) 역할  
그래서 MyISAM이나 MEMORY 테이블에서는 프라이머리 키와 세컨더리 인덱스는 구조적으로 차이가 없음  

InnoDB 스토리지 엔진은 클러스터링 키 값이 변경될 때마다 모든 인덱스에 저장된 레코드 주소값을 변경해야하는 오버헤드 가능성 존재  
이런 오버헤드를 제거하기 위해서 세컨더리 인덱스는 해당 레코드 주소값이 아닌 프라이머리 키 값을 저장하도록 구현  

```sql
CREATE TABLE employees (
  emp_no INT NOT NULL,
  first_name VARCHAR(20) NOT NULL,
  PRIMARY KEY (emp_no),
  INDEX ix_firstname (first_name)
);

SELECT * FROM employees WHERE first_name = 'Aamer';
```

- MyISAM  
  `ix_firstname` 인덱스를 검색해서 레코드 주소를 확인  
  레코드 주소를 이용해 최종 레코드 조회  

- InnoDB  
  `ix_firstname` 인덱스를 검색해서 프라이머리 키 값을 확인  
  프라이머리 키 인덱스를 순회해서 최종 레코드 조회  

<br>

### 클러스터링 인덱스의 장점과 단점
|  |  |
|--|--|
| **장점** | 프라이머리 키로 검색할 때 처리 성능이 매우 빠름 <br> 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 보유해서 커버링 인덱스 처리 용이 |
| **단점** | 프라이머리 키 값 크기가 큰 경우 전체적인 인덱스 크기가 커짐 <br> 세컨더리 인덱스를 통해 검색해도 프라이머리 키로 재검색 필수 <br> 레코드 생성시 프라이머리 키에 의한 레코드 저장 위치 결정되기 때문에 성능이 느림 <br>  프라이머리 키를 변경할때 레코드 삭제후 생성 필수 |

클러스터링 인덱스는 빠른 읽기가 가능하지만 느린 쓰기 발생  
일반적인 온라인 트랜잭션 환경(`OLTP, On-Line Transaction Processing`)에서는 쓰기/읽기 비율이 2:8, 1:9 정도  

<br>

### 클러스터링 인덱스 키의 크기
클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키 값을 포함  
일반적인 테이블에 사용되는 인덱스는 4 ~ 5개  

| 프라이머리 키 크기 | 레코드당 인덱스 크기 증가량 | 100만 건 레코드 저장시 인덱스 크기 증가량 |
|--|--|--|
| 10byte | 10 * 5 = 50 byte | 50 * 1,000,000 = 47MB |
| 50byte | 50 * 5 = 250 byte | 250 * 1,000,000 = 238MB |

<br>

### 프라이머리 키는 AUTO-INREMENT보다는 업무적인 칼럼으로 생성(가능한 경우)
클러스터링되지 않은 테이블에서는 프라이머리 키로 뭘 선택해도 성능 차이 미미  
설령 칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있는 키로 설정하는 것을 권장  

<br>

### 프라이머리 키는 반드시 명시할 것
가능하면 `AUTO_INCREMENT` 칼럼을 이용해서라도 프라이머리 키를 명시적으로 생성하는 것을 권장  
자동 추가된 프라이머리 키는 사용자가 접근 불가  
정의하지 않은 것과 `AUTO_INCREMENT` 칼럼으로 생성하는 것이 내부적으로 차이가 없음  

<br>

### AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우
여러 개의 칼럼이 복합으로 프라이머리 키가 만들어지는 경우 크기가 커질 가능성 존재  
만약 세컨더리 인덱스가 필요치 않다면 그대로 사용하는 것을 권장  
만약 아니라면 `AUTO-INCREMENT` 칼럼을 추가하고 해당 값을 인조 식별자(`Surrogate key`)로 대체  

<br>
