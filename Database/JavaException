//예외계층
  Object : 예외도 객체, 모든 객체의 최상위 부모 객체
  Throwable : 최상위 예외, 하위에 Exception, Error 존재
  Error : 메모리 부족 또는 심각한 시스템 오류와 같이 어플리케이션에서 복구 불가한 시스템 예외(언체크 예외)
    어플리케이션 개발자가 이 예외를 잡으려고 해서는 안됨(try ~ catch (Throwable, Error) 금지)
  Exception : 어플리케이션 로직에서 사용할 수 있는 실질적 최상위 예외
    그 하위 예외(SQLException, IOException)는 모두 컴파일러가 체크하는 체크 예외(RuntimeException 제외)
  RuntimeException : 런타임에 발생하는 언체크 예외
    NullPointerException, IllegalArgumentException 등 런타임 예외들이 속함


//예외 기본 규칙
  예외는 폭탄 돌리기와 유사
  잡아서 처리하거나 처리할 수 없으면 밖으로 던짐
    1. 예외를 잡아서 처리
    2. 예외를 잡거나 던질 때 지정한 예외뿐만 아니라 그 예외의 자식둘도 함꼐 처리 
  지속적으로 예외를 밖으로 던질 경우 
    main() 쓰레드의 경우 예외 로그 출력하고 시스템 종료
    웹 어플리케이션의 경우 사용자 요청으로 인한 시스템 종료를 막기위해 WAS가 해당 예외를 받아 처리


//체크 예외
  체크 예외의 경우 발생 시점에서 처리하지 않고 밖으로 던지면 메서드에 throws 표기
  체크 예외를 throws 선언을 하지않은 경우 컴파일 오류발생


//체크 예외 장단점
  장점 : 개발자가 실수로 예외를 누락하지 않도록 컴파일러를 통해 확인가능
  단점 : 모든 체크 예외를 반드시 잡거나 던지도록 처리, 의존관계에 의한 단점


//언체크 예외
  RuntimeException과 그 하위 예외를 언체크 예외 또는 런타임 예외로 분류
  컴파일러가 예외를 체크하지 않음
  언체크 예외는 throws 선언을 생략 가능


//언체크 예외 장단점
  장점 : 처리할 수 없는 예외에 경우 무시 가능
  단점 : 개발자가 실수로 예외를 누락할 가능성 존재


//체크 예외 활용
  1. 기본적으로 언체크 예외 사용 권장
    하위 계층에서 해결하지 못하는 체크 예외에 대해서 상위 계층에서 지속적으로 throws 선언
    상위 계층이 특정 기술 체크 예외(SQLException, JPAException)를 의존하는 문제 발생
    
  2. 체크 예외는 비즈니스 로직상 의도적으로 던지는 예외에만 사용
    이 경우 해당 예외를 잡아서 반드시 처리해야하는 경우(절대로 놓처서는 안되는 경우 사용)









