# 인덱스
인덱스 특성과 치이는 물리 수준 모델링에 중요한 요소  
기존 MyISAM 스토리지 엔진에서만 제공하던 전문 검색, 위치 기반 검색 기능도 지원  
쿼리 튜닝의 기본  

<br>

## 유니크 인덱스
유니크는 사실 인덱스라기보단 제약 조건에 가까움  
MySQL에서는 인덱스 없이 유니크 제약만 설정 불가  
유니크 인덱스에서 `NULL`도 저장 가능, 또한 `NULL`은 특정 값이 아니기 때문에 2개 이상 저장 가능  
프라이머리 키는 `NULL`이 허용되지 않는 유니크 인덱스와 유사하지만 클러스터링 키 역할도 맡음  

<br>

### 유니크 인덱스와 일반 세컨더리 인덱스의 비교
유니크 인덱스와 일반 세컨더리 인덱스는 사실 인덱스 구조상 차이가 없음  

<br>

### 인덱스 읽기
유니크 인덱스와 일반 세컨더리 인덱스는 성능상 차이가 거의 없음  
CPU에서 칼럼 값을 비교하는 작업이 있기 때문  
세컨더리 인덱스는 중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느린 것이지, 인덱스 자체 특성 때문은 아님  
하나의 값을 검색하는 경우, 유니크 인덱스와 일반 세컨더리 인덱스는 사용되는 실행 계획이 다름  

<br>

### 인덱스 쓰기
유니크 인덱스는 키 값을 쓸 때는 중복된 값이 있는지 확인하는 과정이 추가로 필요  
일반 세컨더리 인덱스보다 쓰기 성능이 느림  
유니크 인덱스에서 중복된 값을 확인할 때는 읽기 잠금, 쓰기를 할 때는 쓰기 잠금을 사용해서 데드락이 빈번히 발생  
또한 InnoDB 스토리지 엔진은 인덱스 키의 저장을 버퍼링하기 위해 체인지 버퍼를 사용  
인덱스 저장이나 변경 작업이 상당히 빨리 처리되지만, 유니크 인덱스는 중복 체크로 인해 버퍼링하지 못함  

<br>

### 유니크 인덱스 사용 시 주의사항
정말 필요한 경우가 아닌, 성능이 좋아질 것을 예상하고 유니크 인덱스를 생성하는 것은 권장하지 않음  
동일한 칼럼에 대해 유니크 인덱스는 일반 다른 인덱스를 분리해서 생성할 필요 없음  
또한 동일한 칼럼에 대해 프라이머리 키와 유니크 인덱스를 동일하게 생성한 경우도 필요 없음  
프라이머리 키를 제외하고 유일성이 꼭 보장돼야 하는 칼럼에 대해서만 유니크 인덱스를 생성  

```sql
CREATE TABLE tb_unique (
  id INTEGER NOT NULL,
  nick_name VARCHAR(100),
  PRIMARY KEY (id),
  UNIQUE INDEX ux_nickname (nick_name),
  INDEX ix_nickname (nick_name)
);
```

<br>
