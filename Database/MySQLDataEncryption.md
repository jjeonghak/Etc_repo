# 데이터 암호화

5.7 버전부터 지원된 데이터 암호화는 테이블스페이스에 대해서만 기능 지원  
8.0 버전부터 리두 로그, 언두 로그, 복제를 위한 바이너리 로그 등 모두 암호화 기능 지원  

<br>

## MySQL 서버의 데이터 암호화

<img width="350" alt="distio" src="https://github.com/user-attachments/assets/d282ad9a-71d8-42c2-8e7f-1dea1c7bd103" />

서버와 디스크 사이에서 조회/쓰기 지점에서만 암호화 처리 필요  
즉 I/O 레이어에서만 데이터 암호화 및 복호화 과정 실행  
서버와 사용자는 데이터 암호화 기능 활성화 여부에 상관없이 똑같이 서비스 이용 가능  
이러한 암호화 방식을 `TDE(transparent data encryption)`이라고 표현  

<br>

### 2단계 키 관리
`TDE`에서 암호화 키는 키링(`KeyRing`) 플러그인에 의해 관리  
MySQL 커뮤니티 에디션에서는 `keyring_file` 플러그인만 사용 가능  
2단계(2-Tier) 키 관리 방식을 사용  

<br>

<img width="550" alt="2-tier" src="https://github.com/user-attachments/assets/f8ffbe2f-b127-4308-a1e0-571248f1be55" />

<br>

데이터 암호화는 마스터 키와 테이블스페이스 키 두 종류 보유, 테이블스페이스 키는 프라이빗 키로도 표현  
외부 키 관리 솔루션 또는 디스크 파일에서 마스터 키를 조회  
암호화된 테이블이 생성될 때마다 임의의 테이블스페이스 키를 발급  
서버는 마스터 키를 사용해서 테이블스페이스 키를 암호화해 각 테이블 데이터 파일 헤더에 저장  
이렇게 생성된 테이블스페이스 키는 테이블 삭제 전까지 절대 변경되지 않음  
테이블스페이스 키는 외부로 절대 노출되지 않지만, 마스터 키는 외부 파일을 이용하기 때문에 주기적으로 변경 필요  

<br>

```sql
ALTER INSTANCE ROTATE INNODB MASTER KEY;
```

마스터 키를 변경하면 모든 테이블스페이스 키를 복호화한 후 다시 새로운 마스터 키로 암호화  
마스터 키가 변경되도 테이블스페이스 키 자체와 데이터 파일의 데이터는 전혀 변경되지 않음  
2단계 암호화 방식을 이용해서 암호화 키 변경으로 인한 과도한 시스템 부하 방지  

기본적으로 `TDE` 지원 알고리즘은 `AES 256bit`, 이외의 알고리즘은 지원하지 않음  
테이블스페이스 키는 `AES-256 ECB(Electronic Code Book)` 알고리즘 사용  
실제 데이터 파일은 `AES-256 CBC(Cipher Block Chaining)` 알고리즘 사용  

<br>

### 암호화와 성능
`TDE` 방식이기 때문에 디스크로부터 한번 읽은 데이터 페이지는 복호화되어 버퍼풀에 적재  
한번 적재되면 암호화되지 않은 테이블과 동일한 성능  
하지만 버퍼풀에 없는 데이터를 디스크로부터 조회하는 경우 복호화 과정 필요, 쿼리 지연 가능성 존재  
또한 변경 사항을 디스크로 동기화할때 암호화 과정 필요, 하지만 데이터 저장은 백그라운드 스레드가 수행하기에 쿼리 지연 없음  

`AES(Advanced Encryption Standard)` 암호화 알고리즘은 평문의 길이가 짧은 경우 키의 크기에 따라 용량 증가 가능성 존재  
하지만 데이터 페이지는 암호화 키보다 훨씬 크기때문에 평문과 동일한 크기의 암호화 결과 반환  
따라서 메모리 사용 효율이 떨어지는 현상은 발생하지 않음  

테이블 압축과 암호화가 동시에 적용된 경우 우선 압축 실행  
- 일반적으로 암호화된 결과문은 랜덤한 바이트 배열을 반환하는데, 압축률 저하 유발  
- 버퍼풀은 압축된 페이지와 압축 해제된 페이지를 모두 보유하기 때문에 압축을 먼저 실행해야 매번 압축 해제시 암복호화 작업을 수행하지 않음  

<br>

```sql
## 디스크 읽기/쓰기 속도 성능 조회
SELECT (SUM(SUM_TIMER_READ) / SUM(COUNT_READ)) / 1000000000 as avg_read_latency_ms,
       (SUM()SUM_TIMER_WRITE) / SUM(COUNT_WRITE)) / 1000000000 as avg_write_latency_ms
FROM performance_schema.file_summary_by_instance
WHERE file_name LIKE '%DB_NAME/TABLE_NAME%';
```

| 암호화 여부 | 테이블 크기(GB) | Read Latency(ms) | Write Latency(ms) |
|--|--|--|--|
| 비활성화 | 1.3 | 0.56 | 0.02 |
| 비활성화 | 2.7 | 0.16 | 0.02 |
| 비활성화 | 3.7 | 0.49 | 0.02 |
| 비활성화 | 106.6 | 0.34 | 0.02 |
| 비활성화 | 141.0 | 0.25 | 0.02 |
| 활성화 | 2.0 | 1.19 | 0.11 |
| 활성화 | 4.8 | 1.50 | 0.13 |
| 활성화 | 206.5 | 1.44 | 0.12 |

<br>

### 암호화와 복제























