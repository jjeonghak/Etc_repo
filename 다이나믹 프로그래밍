// 다이나믹 프로그래밍(DP, Dynamic Programming)이란 하나의 문제는 단 한번만 풀도록 하는 알고리즘
// 입력이 고정되어 있을 때 그 결과가 항상 같은 참조적 투명함수(Referential transparent function)일 때만 메모이제이션(Memoization)을 이용
// 계산의 중복 횟수가 깊이가 깊어질 수록 지수적으로 증가하게 되는 조합폭발(Combinatorial explosion) 방지

동적 계획법
1. 주어진 문제를 완전 탐색을 이용해 해결한다.
2. 중복된 작은 문제를 한 번만 계산하도록 메모이제이션을 적용한다.

// 이때 이미 계산한 값을 저장해 두는 메모리의 장소를 캐시(Cache)라고 하며, 두번 이상 계산되는 작은 문제를 부분 문제(Overlapping subproblems)라고 한다.

 메모이제이션 구현방법
 1) 항상 기저 사례를 제일 먼저 처리 - 입력이 범위를 벗어난 경우 등의 오류 해결
 2) 초기 캐시값 초기화 - 캐시의 해당 위치에 삽입된 값이 초기화 값이라면 이 값은 계산된 반환값이 아님

최적화 문제 동적 계획법
1. 모든 답을 만들어 보고 그 중 최적해의 점수를 반환하는 완전 탐색 알고리즘 설계
2. 전체 답의 점수를 반환하는 것이 아니라, 앞으로 남은 선택들에 해당하는 점수만을 반환하도록 부분 문제 정의 변경
3. 재귀 호충의 입력에 이전의 선택에 관련된 정보가 있다면 꼭 필요한 것만 남기고 제거한다. 문제의 최적 부분 구조가 성립할 경우에는 이전 선택에 관련되는 부분 문제를 많이 만드는 것.
4. 입력이 배열이거나 문자열인 경우 가능하다면 적절한 변환을 통해 메모이제이션할 수 있도록 한다.
5. 메모이제이션 적용

 최적화 문제 답 계산
 1) 재귀 호출의 각 단계에서 최적해를 만들었던 선택을 별도의 배열에 저장한다.
 2) 별도의 재귀 함수를 이용해 이 선택을 따라가며 각 선택지를 저장 혹은 출력한다.
 
재귀적 동적 계획법
* 장점
 1) 좀더 직관적인 코드
 2) 부분 문제 간의 의존 관계나 계산 순서를 인지하기 편함
 3) 전체 부분 문제 중 일부의 답만 필요한 경우 빠르게 동작
* 단점
 1) 슬라이딩 윈도 기법 사용불가
 2) 스택 오버플로 우려
 
반복적 동적 계획법
* 장점
 1) 구현이 대개 더 짧다
 2) 재귀 호출이 아닌 반복문 사용으로 좀더 빠르게 동작
 3) 슬라이딩 윈도 기법 사용가능
* 단점
 1) 비직관적인 코드
 2) 부분 문제 간의 의존 관계 및 계산 순서 고려
 
 슬라이딩 윈도(Sliding window)를 이용한 공간 복잡도 감소
 - 데이터 전체를 메모리에 유지하는 것이 아닌 필요한 부분만을 저장하는 기법
