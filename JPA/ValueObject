//JPA 데이터 타입 분류
  1. 엔티티 타입
      @Entity 정의 객체
      데이터가 변해도 식별자로 지속적인 추적가능
        
  2. 값 타입
      자바 기본 타입(int, String)이나 객체
      식별자가 없고 값만 있으므로 변경시 추적불가


//값 타입
  1. 기본값 타입
  2. 임베디드 타입(embedded type, 복합 값 타입)
  3. 컬렉션 값 타입(collection value type)


//기본값 타입
  생명주기를 엔티티에 의존
  값 타입은 공유금지(부수효과 금지)
    1. 자바 기본 타입(primitive type)
      항상 값을 복사해서 사용하므로 공유되지 않음
          int a = 10;
          int b = a;
          a = 20;  //a == 20, b == 10, pass by Value
    
    2. 래퍼 클래스(wrapper class),특수한 클래스(String)
      공유가능하지만 변경은 불가(참조를 위한 인스턴스)
      산술 연산을 위해 정의된 클래스가 아니므로 인스턴스에 저장된 값 변경불가
      박싱으로 동등 연산자 비교는 언제나 false
      오토박싱으로 비교시 -128 ~ 127까지는 캐싱데이터 사용으로 true
          Integer num = new Integer(10);  //박싱(boxing)
          int n = num.intValue();  //언박싱(unboxing)
          Character ch = 'X';  //오토박싱(autoboxing)
          char c = ch;  //오토언박싱(autounboxing)
    

//임베디드 타입
  새로운 값 타입을 직접 정의 가능
  JPA는 임베디드 타입
  주로 기본 값 타입을 모아서 만들기 때문에 복합 값 타입
  기본 값 타입의 모임이므로 임베디드 타입도 값 타입과 유사
  부모 엔티티의 생명주기에 의존(연관관계 OneToOne과의 차이)
  데이터베이스 테이블은 임베드디 타입 사용 유무에 따라 변경사항 없음
  재사용과 높은 응집도, 엔티티의 값일 뿐
      @Embeddable : 값 타입 정의하는 곳에 어노테이션 추가, 기본생성자 필수
      @Embedded : 값 타입 사용되는 곳에 어노테이션 추가
      @AttributeOverrides : 한 엔티티에서 재사용시 컬럼명 속성 재정의
      @AttributeOverride : 한 엔티티에서 재사용시 컬럼명 속성 재정의
          @AttributeOverrides({@AttributeOverride(name = "columnName",
                    column = @Column(name = "NEW_COLUMN_NAME")})


//객체 타입의 한계
  항상 값을 복사해서 사용하면 공유 참조로 인해 발생하는 부수효과 예방가능
  임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입(객체의 공유참조 발생)


//불변 객체(immutable object)
  생성 시점 이후 값 변경이 불가능한 객체
  객체 타입을 수정할 수 없게 만들어서 부수효과 방지
  값 타입은 불변객체로 설계(생성자로만 값 설정, 수정자 생성 금지)
  자바가 제공하는 대표적인 불변 객체 : Integer, String
  










