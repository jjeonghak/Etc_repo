// count sort
// 시간 복잡도 : O(N + k)
// k : 정렬한 수중 가장 큰 수
// 모든 수의 중복 횟수를 저장한 후 누적합을 이용해 정렬
// 비교 정렬이 아닌 안정 정렬
// 범위 조건이 있는 경우
// 정렬하는 수가 크지 않다면 사용, 수가 크다면 경로압축 필수


int temp;
int count[number1] = { 0, };//범위조건 : 크기가 number1 이하(0 초기화)
int array[number2]; //데이터량
for (int i = 0; i < number2; i++) { //갯수를 셈
	count[array[i] - 1]++;
}
for (int i = 0; i < number1; i++) { //갯수만큼 출력
	if (count[i] != 0) {
		for (int j = 0; j < count[i]; j++) cout << i + 1;
	}
}
