// count sort
// 시간 복잡도 : O(N + k)
// k : 정렬한 수중 가장 큰 수
// 모든 수의 중복 횟수를 저장한 후 누적합을 이용해 정렬
// 비교 정렬이 아닌 안정 정렬
// 범위 조건이 있는 경우
// 정렬하는 수가 크지 않다면 사용, 수가 크다면 경로압축 필수


int index[n];
int count[n];
int result[n];

for (int i = 0; i < n; i++)
    count[index[i]]++;
    
for (int i = 0; i < n; i++)
{
    if (count[index[i]] != 0)
    {
    	result[count[index[i]]] = index[i];
	count[index[i]]--;
    }
}

