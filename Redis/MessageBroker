//메세지 브로커
  서비스 간 커넥션이 실패하는 상황은 언제나 발생 가능
  모듈 간의 통신에서는 되도록 비동기 통신 사용 권장
  서비스 간 통신 불가가 장애로 이어지지 않고 처리하지 못한 메시지를 어딘가에 쌓아 둔 후 나중에 처리

    1. 메시징 큐
      주로 데이터를 생성하는 쪽을 생산자(producer), 데이터를 수신하는 쪽을 소비자(consumer)로 지칭
      생산자는 소비자마다 메시징 큐에 각각 데이터를 푸시
      소비자가 데이터를 읽을 때 큐에서 데이터 삭제
      새로운 소비자 추가시 이전 이벤트는 조회 불가

    2. 이벤트 스트림
      주로 데이터를 생산하는 쪽을 발행자(publisher), 데이터를 조회하는 쪽을 구독자(subscriber)로 지칭
      특정 저장소에 하나의 메시지를 보내고 구독자들은 스트림에서 같은 메시지를 풀
      구독자가 읽어간 후 바로 삭제되지 않음
      새로운 구독자에 대해 스트림에 남아있는 이전 데이터는 조회 가능
      

//레디스를 이용한 메시지 브로커
  pub/sub 기능을 사용해서 메시지 브로커 구현 가능
  발행자가 특정한 채널에 데이터를 전송하면 이 채널을 듣고 있는 모든 소비자는 데이터를 바로 소비 가능
  하지만 메시지가 잘 전달되었는지 등의 정보를 보장하지 않음
  간단한 알림 서비스의 fire-and-forget 패턴이 필요한 경우 유용
  레디스의 list 자료구조는 메시징 큐에 적합
  레디스의 stream을 사용하면 레디스를 완변학 스트림 플랫폼으로 사용 가능
  

//레디스 pub/sub
  레디스 노드에 접근 가능한 모든 클라이언트는 발행자와 구독자가 될 수 있음
  아주 가벼운 수준으로 발행자는 어떤 구독자가 메시지를 읽었는지, 구독자는 메시지가 언제 전달됐는지 등에 대한 메타데이터 제공안함
  특정 구독자에 장애로 인한 메시지 유실 가능성 존재, 정합성이 중요한 데이터 전달에는 적합하지 않음

    PUBLISH channel message            //채널을 수신하고 있는 모든 서버들에게 message 전파
    SUBSCRIBE channel1 ... channelN    //여러 채널 구독 시작, pub/sub 이외의 커맨드 불가, message 타입
    PSUBSCRIBE pattern                 //패턴에 맞는 모든 채널 구독, pmessage 타입

    SSUBSCRIBE, 
    SUNSUBSCRIBE, 
    UNSUBSCRIBE, 
    PUNSUBSCRIBE, 
    PING, RESET, QUIT
  

//클러스터 구조 pub/sub
  하나의 노드에 메시지를 발행하면 모든 노드에 전파
  모든 레디스 노드에 메시지가 복제되는 방식은 클러스터 환경의 핵심 목표와는 부합하지 않음
  starded pub/sub 사용으로 해결 가능
  레디스 7.0 버전에서 기능 추가
  각 채널은 슬롯에 매핑, 클러스터에서 키가 슬롯에 할당되는 것과 동일하게 채널이 할당

    SPUBLISH channel message    //노드의 복제본에만 전달
    SSUBSCRIBE channel


//list 활용
  1. list EX
    트위터 로직 관리자인 라피 크리코리안(Raffi Krikorian)이 QCon 웨비나 발표 내용 포함
    타임라인은 자신이 팔로우한 계정의 게시물 및 자신과 관련 있는 게시물등이 표시
    트위터는 각 유저의 타임라인 캐시 데이터를 레디스 list 자료구조 사용
    RPUSHX 커맨드를 사용해서 이미 캐시된 타임라인이 존재할 때만 데이터 추가
    사용자의 캐시가 이미 존재하는지의 유무를 애플리케이션 확인 과정이 필요 없음
  
      RPUSHX Timelinecache:userB data
      RPUSHX Timelinecache:userC data
      RPUSHX Timelinecache:userD data


  2. list blocking
    이벤트 루프는 이벤트 큐에 신규 이벤트가 있는지 체크
    없는 경우 정해진 시간(polling interval) 동안 대기한 후 다시 확인하는 과정 반복(polling)
    신규 이벤트가 존재하지만 폴링 인터벌 시간 동안 대기 가능성 존재
    이때 list의 블로킹 커맨드(BLPOP, BRPOP)를 사용
    list에 데이터가 있으면 즉시 반환, 없는 경우 데이터가 들어올때까지 설정한 타임아웃만큼 대기 후 nil 값 반환
    반환값이 두개로, 하나는 팝된 리스트의 키값, 나머지 하나는 팝된 값(여러 개의 리스트에서 대기 가능하도록)
  
      BRPOP key1 ... keyN timeout 


  3. list circular queue
    만약 특정 아이템을 계속해서 반복 접근해야하는 클라이언트
    혹은 여러 개의 클라이언트가 병렬적으로 같은 아이템에 접근해야 하는 클라이언트의 경우 list 원형큐 고려
  
      RPOPLPUSH source destination



  






