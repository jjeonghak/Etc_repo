//캐시
  데이터의 원본보다 더 빠르게 엑세스할 수 있는 임시 데이터 저장소
    1. 원본 데이터 저장소에서 원하는 데이터를 찾기 위해 검색하는 시간이 오래 걸리거나, 매번 계산이 필요한 경우
    2. 캐시에서 데이터를 가져오는 것이 원본 데이터 저장소보다 빠른 경우
    3. 캐시에 저장된 데이터의 변경이 잘 일어나지 않는 경우
    4. 캐시에 저장된 데이터가 자주 검색될 경우


//캐시 레디스
  사용이 간단
  인메모리 데이터 저장소이기 때문에 데이터 검색 및 반환이 빠름
  자체적으로 고가용성 기능을 보유
  센티널 또는 클러스터 기능을 사용해 장애 극복 가능


//캐시 전략
  캐시는 데이터베이스에 저장돼 있는 데이터를 단순히 복사해 온 값
  원본 데이터와 동일한 값을 갖도록 유지 필수
  캐시 불일치(cache inconsistency)를 피하기 위한 전략 필수

    1. 읽기 전략 - look aside
      레디스를 캐시로 사용할 때 가장 일반적인 읽기 전략
      어플리케이션은 찾고자 하는 데이터를 캐시에서 우선 탐색
      없는 경우 캐시 미스 발생
      원본 데이터베이스에 접근해 데이터를 찾고 다시 캐시에 저장
      레디스 장애시 전체 서비스 장애로 이어지지 않음
      미리 데이터베이스에서 캐시로 데이터를 밀어주는 캐시 워밍(cache warming) 작업 가능
  
    2. 쓰기 전략 - write through
      데이터베이스 업데이트시 매번 캐시도 업데이트
      캐시는 항상 최신 데이터를 보유
      매번 2개의 저장소에 저장되는 레이턴시 발생
      캐시에 모든 데이터가 저장되기 때문에 불필요한 리소스 낭비 발생 가능성 존재
      때문에 데이터를 저장할 때 만료시간 사용하는 것 권장

    3. 쓰기 전략 - cache invalidation
      데이터베이스에 값을 업데이트할 때마다 캐시에서는 데이터를 삭제
      데이터 삭제가 생성보다 리소스를 절약
      write through 단점을 보완한 방법

    4. 쓰기 전략 - write behind(write back)
      쓰기가 빈번하게 일어나는 경우 사용
      먼저 캐시에 데이터 업데이트 이후 특정 시간 또는 건수 등에 따라 비동기적 데이터베이스 업데이트
      저장되는 데이터가 실시간으로 정확하지 않아도 될때 사용
      캐시에 장애 발생시 데이터 손실 발생 가능성 존재


//만료시간
  TTL(Time To Live)는 데이터가 얼마나 오래 저장될 것인지 나타내는 시간 설정
  특정 키에 대한 만료 시간 설정 가능
  일반적으로 초 단위로 표현
  기존 키에 새로운 값을 저장해 키를 덮어 쓸 때는 이전에 설정한 만료 시간 소멸

    SET a 100 EX 60
    EXPIRE a 60
    TTL a

  레디스에서 키가 만료되어 바로 메모리에서 삭제되지 않음
  키는 passive 방식과 active 방식 두가지로 삭제

    1. passive
      사용자가 접근할 때 키가 만료된 경우 메모리에서 수동적으로 삭제

    2. active
      TTL 값이 존재하는 키 중 랜덤하게 20개 추출 후 만료된 키를 삭제
      만약 25% 이상 삭제되면 다시 20개의 키를 랜덤하게 추출, 아니라면 뽑아놓은 키를 다시 확인
      이러한 과정을 1초에 10번씩 수행


//메모리 관리
  레디스의 메모리는 제한적
  메모리의 용량을 초과하는 양의 데이터가 저장되면 내부 정책을 이용해 어떤 키를 삭제할지 결정
  최대 용량을 설정하는 maxmemory 설정과 처리 방식 maxmemory-policy 설정을 이용

    1. Noeviction
      기본 처리 방식
      데이터가 가득 차면 데이터를 삭제하지 않고 데이터 저장 에러를 반환
      관리자가 직접 데이터를 지워야하기 때문에 캐시로 이용할때 권장하지 않음

    2. LRU(Least-Recently Used) eviction
      가장 최근에 사용되지 않은 데이터부터 삭제
        volatile-lru: 만료시간이 설정된 키에 한해서 LRU 방식 적용
        allkeys-lru: 모든 키에 대해 LRU 방식 적용, 잘 모르겠다면 이 방식으로 사용하기를 권장

    3. LFU(Least-Frequently Used) eviction
      가장 자주 사용되지 않은 데이터부터 삭제
        volatile-lfu: 만료시간이 설정된 키에 한해서 LFU 방식 적용
        allkeys-lfu: 모든 키에 대해 LFU 방식 적용

    4. RANDOM eviction
      레디스에 저장된 키 중 하나를 임의로 골라내 삭제
      삭제될 키 값을 계산하지 않아도 된다는 점에서 레디스 부하를 줄여줌
      레디스 부하를 줄이기 위한다는 이유로 사용하는 것은 권장하지 않음
        volatile-random: 만료시간이 설정된 키에 한해서 RANDOM 방식 적용
        allkeys-random: 모든 키에 대해 RANDOM 방식 적용

    5. Volatile-ttl
      만료시간이 가장 작은 키를 삭제


//캐시 스탬피드 현상
  레디스를 캐시로 활용할 때 모든 키에 대해 만료시간을 설정하는 것을 권장
  대규모 트래픽 환경에서 어떻게 만료시간을 설정하느냐에 따라 캐시 스탬피드(cache stampede) 현상 발생
  캐시 데이터가 만료되면 여러 서버에서 데이터베이스 값을 동시에 읽고(duplicate read) 캐시에 쓰려고함(duplicate write)
  한번 캐시 스탬피드 현상이 발생하면 결과적으로 계단식 실패(cascading failure)로 이어짐

    1. 적절한 만료시간 설정
      너무 짧지 않게 만료시간 설정

    2. 선계산
      캐시 스탬피드가 문제되는 이유는 데이터가 만료되는 시점에 여러 어플리케이션에서 동시다발적으로 이를 인지 후 동시 작업
      만약 키가 실제로 만료되기 전에 이 값을 미리 갱신해준다면 해결

        ttl - (random() * expiry_gap) > 0
      
    3. PER(Probabilistic Early Recomputation) 알고리즘
      캐시 값이 만료되기 전에 언제 데이터베이스에 접근해서 값을 읽어오면 되는지 최적으로 계산

        currnetTime - (timeToCompute * beta * log(rand())) > expiry
        
      currentTime: 현재 남은 만료시간
      timeToCompute: 캐시된 값을 다시 계산하는데 걸리는 시간
      beta: 기본적으로 1.0보다 큰 값
      rand(): 0과 1 사이의 랜덤한 값을 반환하는 함수
      expiry: 키를 재설정할때 새로 넣어줄 만료시간


//세션스토어 레디스
  세션이란 서비스를 사용하는 클라이언트의 상태 정보를 의미
  레디스의 hash 자료구조는 세션 데이터를 저장하기에 알맞은 형태

    HMSET usersession:1 Name Garimoo IP 10:20:104:30 Hits 1


//세션과 캐시 비교
  레디스 캐시는 데이터베이스의 완벽한 서브셋으로 동작
  즉, 캐시가 가지고 있는 데이터는 데이터베이스에 모두 저장
  레디스 세션은 세션이 활성화된 상태에서는 세션에만 데이터 저장
  세션 종료시 세션 데이터를 데이터베이스에 저장할지 삭제할지 결정




