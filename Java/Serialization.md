## 직렬화
객체를 바이트 스트림으로 인코딩(직렬화)하고 그 바이트 스트림으로부터 다시 객체를 재구성(역직렬화)  
직렬화된 객체는 다른 VM에 전송하거나 디스크에 저장한 후 나중에 역직렬화 가능  
ObjectInputStream의 readObject 메서드가 객체 그래프 역직렬화 메서드  
분산 객체 생성가능  
보안적으로 취약점이 존재함으로 신중하게 제작한 바이트 스트림만 역직렬화 권장  

<br>

## 직렬화 한계
1997년 자바에 처음으로 도입  
연구용 언어 모듈라-3(Modula-3)에서 시도된 기술  
직렬화는 공격 범위가 너무 넓고 지속적으로 넓어져 방어하기 어려움  
신뢰할 수 없는 스트림을 역직렬화하면 원격 코드 실행, 서비스 거부등의 공격으로 이어짐  
직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것  
크로스-플랫폼 구조화된 데이터 표현 사용 권장  
직렬화를 피할 수 없다면 객체 역직렬화 필터링(java.io.ObjectInputFilter) 사용  

<br>
  
## 가젯(gadget)
역직렬화 과정에서 호출되어 잠재적으로 위험한 동작을 수행하는 메서드  
여러 가젯을 함께 사용하여 가젯 체인을 구성 가능  
공격자의 기반 하드웨어 네이티브 코드를 실행할 수 있는 강력한 가젯 체인도 발견  

<br>

## 역직렬화 폭탄(deserialization bomb)
역직렬화 소요 시간이 긴 짧은 스트림(서비스 거부 공격에 쉽게 노출)  

````java
//바우터르 쿠카르츠의 HashSet 역직렬화 폭탄
static byte[] bomb() {
    Set<Object> root = new HashSet<>();
    Set<Object> s1 = root;
    Set<Object> s2 = new HashSet<>();
    for (int i = 0; i < 100; i++) {
        Set<Object> t1 = new HashSet<>();
        Set<Object> t2 = new HashSet<>();
        t1.add("t1");
        t2.add("t2")
        s1.add(t1);
        s1.add(t2);
        s2.add(t1);
        s2.add(t2);
        s1 = t1;
        s2 = t2;
    }
    return serialize(root);
}
````

<br>

이 객체 그래프는 201개의 HashSet 인스턴스로 구성  
그 각각은 3개 이하의 객체 참조를 가짐  
스트림 전체 크기는 5744바이트, 역직렬화는 무한에 가까운 시간동안 지속  
HashSet 인스턴스를 역직렬화하려면 그 원소들의 해시코드를 계산하는 것에 문제점 발생  
루트 HashSet에 담긴 두 원소는 각각 다른 HashSet 두 원소를 가지며 이 구조의 깊이는 100단계  
결국 역직렬화를 위해 HashCode 메서드를 2^100번 호출  

<br>

## 크로스-플랫폼 구조화된 데이터 표현(cross-platform structured-data representation)
객체와 바이트 시퀀스를 변환해주는 다른 메커니즘  
자바 직렬화의 여러 위험을 회피  
임의 객체 그래프를 자동으로 직렬화/역직렬화하지 않고 속성-값 쌍의 집합으로 구성된 간단한 구조화된 데이터 객체 사용  
기본 타입과 배열만 지원  
JSON과 프로토콜 버퍼(Protocol Buffers)를 주로 사용  
언어 중립적이라고 하지만 JSON은 자바스크립트용, 프로토콜 버퍼는 C++용으로 설계  
JSON은 텍스트 기반, 프로토콜 버퍼는 이진 표현 기반  
  
<br>

## 객체 역직렬화 필터
자바 9에 추가, 이전 버전에 사용 가능하도록 이식  
데이터 스트림이 역직렬화되기 전에 필터를 설치  
클래스 단위로 특정 클래스를 받아들이거나 거부하는 기능  
기본 수용 모드에서는 블랙리스트에 기록된 잠재적 위험 클래스 거부  
기본 거부 모드에서는 화이트리스트에 기록된 안전한 클래스 수용  
블랙리스트보단 화이트리스트 방식 권장  

<br>
