## 마이크로서비스
REST 또는 gRPC 같은 가벼운 프로토콜을 응용한 메시지 브로커 또는 서비스 간 통심 중심의 파이프로 통신  
서비스 개별 데이터 모델 및 DB 보유  

<br>

## 마이크로서비스 장점
1. 크고 복잡한 애플리케이션을 지속적으로 전달/배포 가능  
    테스트성 : 상대적으로 크기가 작아서 자동화 테스트 작성이 쉬움  
    배포성 : 독립적인 배포가 가능  
    자율성, 느슨한 결합 : 다른 팀과 독립적으로 개발 가능  

2. 서비스가 작아 관리하기 용이
    코드베이스가 작아서 각 서비스 시동 시간이 훨씬 빠름  

3. 서비스를 독립적으로 배포/확장 가능  
    독립적으로 인스턴스 복제/파티셔닝 확장 가능  

4. 결함 격리  
    어떤 서비스에 메모리 누수 같은 결함이 발생해도 다른 서비스에 영향 없음  

5. 신기술 시험/도입 용이  
    기술 스택 연구에 오랜 시간 소요 안함  
    서비스에 맞는 언어와 프레임워크 선택의 자유성  

<br>

## 마이크로서비스 단점
1. 딱 맞는 서비스 탐색이 쉽지 않음  
    시스템을 여러 서비스로 분해하는 구체적인 알고리즘이 없음  
    최악의 경우 모놀리식/마이크로서비스 단점만 존재하는 분산 모놀리스 구축  
    반드시 함께 배포해야하는 결합도 높은 서비스들로 이루어진 시스템  

2. 분산 시스템의 복잡성  
    서비스 간 통신에 필수적인 IPC 역시 단순 메서드 호출보다 복잡  
    사용 불능, 지연시간이 긴 원격 서비스, 부분 실패한 서비스 처리 필수  

3. 여러 서비스에 걸친 공통 기능은 배포시 주의  
    여러 개발 팀 간의 세심한 조율 필요  

4. 도입 시기를 결정하기 어려움  
    애플리케이션 수명 주기 중 어느 시점에 도입할지 결정하는 것도 부담  

<br>

## 마이크로서비스 아키텍처 패턴 언어  
모놀리식/마이크로서비스 결정에 수많은 트레이드 오프 검토 필요  
인프라 패턴 : 주로 개발 영역 밖의 인프라 문제를 해결  
어플리케이션 인프라 : 개발에도 영향을 미치는 인프라 문제 해결  
어플리케이션 패턴 : 개발 영역의 문제를 해결  

1. 강제 조항  
    문제 해결을 위해 반드시 처리해야 할 이슈  

2. 결과 맥락  
    장점 : 해결된 강제 조항 등 패턴의 좋은 점  
    단점 : 미해결 강제 조항 등 패턴의 나쁜 점  
    이슈 : 패턴 적용시 발생한 새로운 문제점  

3. 연관 패턴
    선행자 : 이 패턴을 필요하게 만든 선행 패턴  
    후행자 : 이 패턴으로 야기된 이슈를 해결하는 패턴  
    대안 : 이 패턴의 대체 솔루션을 제공하는 패턴  
    일반화 : 문제를 해결하는 일반적인 솔루션에 해당하는 패턴  
    세분화 : 특정 패턴을 더 세부적으로 나타낸 형태  

<br>

## 어플리케이션 분해 패턴
1. 통신 패턴  
    통신 스타일 : 어떤 종류의 IPC를 사용할지  
    디스커버리 : 서비스 클라아인트는 서비스 인스턴스의 IP 주소를 어떤 방식으로 가져올지  
    신뢰성 : 서비스 불능시 서비스 간 통신의 신뢰성 보장을 어떤 방식으로 할지  
    트랜잭셔널 메시징 : 비지니스 데이터를 업데이트하는 DB 트랜잭션에 메시지 송신 및 발행하는 행위를 어떤 방식으로 통합할지  
    외부 API : 어플리케이션 클라이언트는 서비스와 어떤 방식으로 통신할지   

2. 트랜잭션 관리를 위한 데이터 일관성 패턴  
    기존 분산 트랜잭션이 아닌 사가 패턴(saga pattern)에 따라 데이터 일관성을 유지  

3. 데이터 쿼리 패턴  
    서비스마다 DB 존재시 서비스가 소유한 데이터를 조인하는 쿼리도 문제 발생  
    API 조합 패턴(composition pattern) : 하나 이상의 서비스를 호출해서 그 결과를 조합  
    CQRS(command query responsibility segregation) : 하나 이상의 데이터 레플리카를 유지  

4. 서비스 배포 패턴  
    고도호 자동화한 배포 인프라 필수  

5. 관측성 패턴  
    요청 결과가 클라이언트에 반환되기까지 어떤 서비스를 오갈지 알수 없음  
    헬스 체크 API : 서비스 헬스를 반환하는 엔드포인트를 표출  
    로그 수집 : 서비스 내역을 기록 및 중앙 로깅 서버에 로그 출력  
    분산 추적 : 각 외부 요청마다 ID 부여하고 서비스 통과하는 과정 추적  
    예외 추적 : 예외 발생시 예외 추적 서비스에 보고  
    어플리케이션 지표 : 카운터, 게이지 등의 지표를 측정하여 지쵸 서버에 표출  
    감사 로깅 : 사용자 행위 기록  

6. 서비스 테스트 자동화 패턴  
    컨슈머 주도 계약 테스트(consumer-driven contract test) : 클라이언트 의도대로 서비스 동작 여부 확인  
    컨슈머 쪽 계약 테스트(consumer-side contract test) : 클라이언트와 서비스 상호 통신 가능 여부 확인  
    서비스 컴포넌트 테스트(service component test) : 서비스를 따로 테스트  

7. 횡단 관심사 처리 패턴  
    공통 관심사를 처리하는 마이크로서비스 섀시(chassis) 패턴을 적용 권장  

8. 보안 패턴  
    API 게이트웨이가 신원, 역할 등 사용자 정보를 인증한 후 호출할 서비스에 관련 정보 전달  
    
<br>

