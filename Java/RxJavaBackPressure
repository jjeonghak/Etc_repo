//RxJava 흐름 제어 방식
  내장된 연산자를 사용한 샘플링이나 일괄 처리와 같은 다양한 흐름 제어 방식 구현
  구독자는 배압을 사용해서 처리할 수 있는 만큼 항목을 요청하고 전파


//주기적인 샘플링과 스로틀링
  sample() 연산자는 업스트림 Observable을 주기적으로 관찰, 마지막 이벤트는 버림
  주기별로 관측값을 방출, 관측 중에 이벤트 발생 없다면 방출되는 다운스트림 없음
  2.1부터 sample(long period, TimeUnit unit, boolean emitLast) 오버로드 형태 제공
  인자로 Observable(샘플러) 가능
  throttleLast() 메서드로는 지정된 기간 내에 가장 최근 이벤트를 방출(sample())
  throttleFirst() 메서드는 지정된 기간 내에 첫 번째 이벤트를 방출(debounce())

    long startTime = System.currentTimeMillis();
    Observable
        .interval(7, TimeUnit.MILLISECONDS)
        .timestamp()
        .sample(1, TimeUnit.SECONDS)
        .map(ts -> ts.getTimestampMillis() - startTime + "ms: " + ts.getValue())
        .take(5)
        .subscribe(System.out::println);

    //1초마다 관측값 방출
    1088ms: 141
    2089ms: 284
    3090ms: 427
    4084ms: 569
    5085ms: 712

    Observable<String> names = Observable
        .just("Mary", "Patricia", "Linda", "Barbara", "Elizabeth", "Jennifer",
            "Maria", "Susan", "Margaret", "Dorothy");
    Observable<Long> absoluteDelayMillis = Observable
        .just(0.1, 0.6, 0.9, 1.1, 3.3, 3.4, 3.5, 3.6, 4.4, 4.8)
        .map(d -> (long)(d * 1_000));
    Observable<String> delayedNames = names
        .zipWith(absoluteDelayMillis, (n, d) -> Observable
            .just(n)
            .delay(d, MILLISECONDS))
        .flatMap(o -> o);
    delayedNames
        .sample(1, SECONDS)
        //.throttleLast(1, SECONDS)
        .subscribe(System.out::println);

    //똑같은 동작
    obs.sample(1, SECONDS);
    obs.sample(Observable.interval(1, SECONDS));


//리스트 버퍼링
  buffer() 연산자는 이벤트 묶음을 실시간으로 List에 집계
  toList() 메서드와는 다르게 모든 이벤트를 하나로 모으지 않고 그룹화한 여러 목록으로 집계
  지정한 버퍼 크기가 될 때까지 버퍼링 후 전체 버퍼를 다운스트림으로 방출
  완료 알림이 온 시점에 내부 버퍼가 비어있지 않다면 그대로 방출
  윈도우 형식의 오버로드 존재
  시간 간격에 따라 일괄 처리하는 오버로드 존재

    Observable
        .range(1, 7)
        .buffer(3)
        .subscribe((List<Integer> list) -> {
            System.out.println(list);
        });

    [1, 2, 3]
    [4, 5, 6]
    [7]

    //세분화된 이벤트를 병합해서 연산 횟수 감소
    Observable
        .subscribe(repository::store);
    Observable
        .buffer(10)
        .subscribe(repository::storeAll);

    //슬라이딩 윈도우 형식의 오버로드 buffer
    Observable
        .range(1, 7)
        .buffer(3, 1)
        .subscribe(System.out::println);

    [1, 2, 3]
    [2, 3, 4]
    [3, 4, 5]
    [4, 5, 6]
    [5, 6, 7]
    [6, 7]
    [7]

    //두번째 인수는 버퍼 크기보다 클 수 있음
    Observable<Integer> odd = Observable
        .range(1, 7)
        .buffer(1, 2)
        .flatMapIterable(list -> list);

    //시간 간격으로 버퍼링
    Obseravble
        .range(1, 7)
        .delay(500, TimeUnit.MILLISECONDS)
        .buffer(1, TimeUnit.SECONDS)
        .subscriber(System.out::println);
  
    Observable
        .range(1, 7)
        .delay(500, TimeUnit.MILLISECONDS)
        .buffer(1, TimeUnit.SECONDS)
        .map(List::size);

    //시간대별로 이벤트 처리
    Observable<Duration> insideBusinessHours = Observable
        .interval(1, TimeUnit.SECONDS)
        .filter(x -> isBusinessHour())
        .map(x -> Duration.ofMillis(100));
    Observable<Duration> outsideBusinessHours = Observable
        .interval(5, TimeUnit.SECONDS)
        .filter(x -> !isBusinessHour())
        .map(x -> Duration.ofMillis(200));
    Observable<Duration> openings = Observable
        .merge(insideBusinessHours, outsideBusinessHours);
    Observalbe<TeleData> upstream = ...
    Observable<List<TeleData>> samples = upstream
        .buffer(openings);

    private static final LocalTime BUSINESS_START = LocalTime.of(9, 0);
    private static final LocalTime BUSINESS_END = LocalTime.of(17, 0);

    private boolean isBusinessHour() {
        ZoneId zone = ZoneId.of("Europe/Warsaw");
        ZonedDateTime zdt = ZonedDateTime.now(zone);
        LocalTime localTime = zdt.toLocalTime();
        return !localTime.isBefore(BUSINESS_START) && !localTime.isAfter(BUSINESS_END);
    }

    //일괄처리 오버로드
    Observable<List<TeleData>> samples = upstream
        .buffer(openings, duration -> empty().delay(duration.toMillis(), MILLISECONDS));


//윈도우
  buffer() 연산자는 현재 버퍼를 다운스트림으로 전달할 때마다 임시 List 생성
  불필요한 가비지 컬렉션이나 메모리 사용을 유발할 가능성 존재
  즉시 이벤트를 처리하기 위한 window() 연산자
  하나의 일괄 처리 또는 버퍼를 포함하는 고정 리스트를 받는 대신 스트림의 스트림을 받음
  int를 인수로 받아 원본에서 이벤트를 고정 크기 목록으로 그룹화하는 오버로드 존재
  시간 단위를 받아 고정된 시간 간격 안에 이벤트를 그룹화하는 오버로드 존재
  개별 일괄 처리의 시작과 끝을 나타내는 사용자 정의 Observable을 인수로 받는 오버로드 존재

    //많은 낭비
    Observable<KeyEvent> eventPerSecond = keyEvents
        .buffer(1, SECONDS)
        .map(List::size);

    //buffer() 연산자와 다른 window()
    Observable<Observable<KeyEvent>> windows = keyEvents.window(1, SECONDS);
    Observable<Integer> eventPerSecond = windows
        .flatMap(eventsInSecond -> eventsInSecond.count());


//낡은 이벤트 건너뛰기
  위의 연산자들은 이벤트 사이의 경과 시간을 고려하지 않움
  바로 이어서 새로운 이벤트 발생시 이전 이벤트를 무시할 가능성 존재
  debounce() 또는 throttleWithTimeout() 연산자는 특정 이벤트 직후에 뒤따른 모든 이벤트를 버림
  지정된 이벤트 이후 타임 윈도우 안에 다른 이벤트가 나타나지 않는 경우 해당 이벤트를 방출
  즉 새로운 이벤트가 앞선 이벤트를 진압
  
    //100ms 이내에 이벤트가 나타나는지 관찰, 나타나는 경우 다시 100ms 대기
    Observable<BigDecimal> prices = tradingPlatform.priceOf("NFLX");
    Observable<BigDecimal> debounced = prices.debounce(100, MILLISECONDS);

    //이벤트 조건에 따른 상이한 관찰 시간 오버로드(debounceSelector)
    prices.debounce(x -> {
        boolean goodPrice = x.compareTo(BigDecimal.valueOf(150)) > 0;
        return Observable
            .empty()
            .delay(goodPrice ? 10 : 100, MILLISECONDS);
    });

    Observable<BigDecimal> pricesOf(String ticker) {
        return Observable
            .interval(50, MILLISECONDS)
            .flatMap(this::randomDelay)
            .map(this::randomStockPrice)
            .map(BigDecimal::valueOf);
    }

    Observable<Long> randomDelay(long x) {
        return Observable
            .just(x)
            .delay((long) (Math.random() * 100), MILLISECONDS);
    }

    double randomStockPrice(long x) {
        return 100 + Math.random() * 10 + (Math.sin(x/100.0)) * 60.0;
    }


//이벤트 고갈 회피
  이벤트가 지속적으로 자주 등장하는 경우 debounce() 연산자가 모든 이벤트 방출을 막는 경우

    Observable
        .interval(99, MILLISECONDS)
        .debounce(100, MILLISECONDS)  //이벤트 방출 안됨
        .timeout(1, SECONDS)          //TimeoutException 발생

    //timeout() 메서드로 회피 - 미묘한 버그
    ConnectableObservable<Long> upstream = Observable
        .interval(99, MILLISECONDS)
        .publish();
    upstream
        .debounce(100, MILLISECONDS)
        .timeout(1, SECONDS, upstream.take(1));
    upstream.connect();

    //재귀를 사용(defer() 메서드를 활용한 생성 지연)
    Observable<Long> timedDebounce(Observable<Long> upstream) {
        Observable<Long> onTimeout = upstream
            .take(1)
            .concatWith(defer(() -> timedDebounce(upstream)));    //defer() 메서드를 활용해 구독할 때 Observalbe 생성
        return upstream
            .debounce(100, MILLISECONDS)
            .timeout(1, SECONDS, onTimeout);
    }










