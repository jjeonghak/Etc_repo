//원소 시퀀스 반환
  자바 7 이전에는 이런 메서드의 반환 타입을 Collection, Set, List, Iterable, 배열 사용
  자바 8 이후에는 스트림을 사용
  Stream 인터페이스는 Iterable 인터페이스가 정의한 추상 메서드를 점부 포함
  하지만 Stream이 Iterable을 확장하지는 않음
  Collection 엔터페이스는 Iterable의 하위 타입이고 stream 메서드도 제공
  원소 시퀀스 반환 공개 API는 Collection 또는 그 하위 타입을 쓰는 게 일반적
  
    //자바 타입 추론의 한계
    for (ProcessHandle ph : ProcessHandle.allProcesses()::iterator) {
        ...
    }
    
    //스트림을 반복하기 위한 끔찍한 우회방식
    for (ProcessHandle ph : (Iterable<ProcessHandle>) ProcessHandle.allProcesses()::iterator) {
        ...
    }
    
    //어댑터 사용 방식
    public static <E> Iterable<E> iterableOf(Stream<E> stream) {
        return stream::iterator;
    }
    
    public static <E> Stream<E> streamOf(Iterable<E> iterable) {
        return StreamSupport.stream(iterable.spliterator(), false);
    }


//스트림 및 컬렉션 차이
  스트림의 게으른 특성 덕분에 컬렉션보다 최적화 가능
  중간 연산은 종단 연산에서 한번에 실행
  
  1. 쇼트서킷(short circuit) : limit 연산을 통해 모든 원소를 처리하지 않음
  2. 루프 퓨전(loop fusion) : filter 및 map은 서로 다른 연산이지만 한과정으로 병합해서 처리
  
    List<String> names = menu.stream()
        .filter(dish -> {
            System.out.println("filtering:" + dish.getName());
            return disg.getCalories() > 300;
        })
        .map(dish -> {
            System.out.println("mapping:" + dish.getName());
            return disg.getName();
        })
        .limit(3)
        .collect(toList());
    
    //결과 : filtering:pork
            mapping:pork
            filtering:beef
            mapping:beef
            filtering:chicken
            mapping:chicken


//컬렉터
  Collector 인터페이스 구현은 스트림의 요소를 어떤 식으로 도출할지 지정
  
  1. 스트림 요소를 하나의 값으로 리듀스하고 요약
  2. 요소 그룹화
  3. 요소 분할


//리듀싱 요약
  컬렉터를 이용한 카운트, counting 컬렉터는 다른 컨렉터와 함께 사용할 때 유용
    long howManyDishes = menu.stream().collect(Collectors.countimg());
    long howManyDishes = menu.stream().count();

  최댓값과 최솟값 검색
    Comparator<Dish> dishCaloriesComparactor = Comparator.comparingInt(Dish::getCalories);
    Optional<Dish> mostCalorieDish = menu.stream()
        .collect(maxBy(dishCaloriesComparactor));
  
  컬렉터 내에 여러 숫자 관련 요약 팩토리 메서드 지원
    summingInt, averagingInt, summarizingInt(IntSummaryStatistics 클래스 반환, count, sum, min, max, average)

  문자열 연결, 내부적으로 Stringbuiler 사용
    String shortMenu = menu.stream().map(Dish::getName).collect(joining());
    String shortMenu = menu.stream().map(Dish::getName).collect(joining(", "));


//범용 리듀싱 요약 연산
  위의 모든 컬렉터는 reducing 팩토리 메서드로 정의 가능
  범용 Collectors.resucing으로 구현
  프로그래밍적 편의성을 위해 특화된 컬렉터를 사용
  세개의 인수를 받아 동작(초기값, 변환함수, BinaryOperator)
  
    int totalCalories = menu.stream()
        .collect(reducing(0, Dish::getCalories, (i, j) -> i + j));
    
    Optional<Dish> mostCalorieDish = menu.stream()
        .collect(reducing((d1, d2) -> d1.getCalories() > d2.getCalories() ? d1 : d2));


//collect 및 reduce 비교
  collect 메서드는 도출하려는 결과를 누적하는 컨테이너를 변경하도록 설계
  reduce는 두 값을 하나로 도출하는 불변형 연산
  
    int totalCalories = menu.stream()
        .collect(reducing(0, Dish::getCalories, Integer::sum));
        
    int totalCalories = menu.stream()
        .map(Dish::getCalories).reduce(Integer::sum).get();
        
    int totalCalories = menu.stream
        .mapToInt(Dish::getCalories).sum();
    
    public static <T> Collector<T, ?, Long> counting() {
        return reducing(0L, e -> 1L, Long::sum);
    }
  
    //잘못사용한 reduce
    stream.reduce(
        new ArrayList<Integer>(), 
        (List<Integer> l1, Integer e) -> {
            l1.add(e);
            return l1;
        },
        (List<Integer> l2, List<Integer> l3) -> {
            l2.addAll(l3);
            return l2;
        }
    );
 

